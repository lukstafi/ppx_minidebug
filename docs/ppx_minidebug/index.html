<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>index (ppx_minidebug.index)</title><meta charset="utf-8"/><link rel="stylesheet" href="../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../index.html">Index</a> &#x00BB; ppx_minidebug</nav><header class="odoc-preamble"><h1 id="ppx_minidebug"><a href="#ppx_minidebug" class="anchor"></a>ppx_minidebug</h1><p><b>Debug logging for OCaml with interactive trace exploration</b></p><p><code>ppx_minidebug</code> is a PPX extension that automatically instruments your OCaml code with debug logging. Traces are stored in a SQLite database and explored via an interactive TUI, making it easy to understand program execution, debug issues, and analyze behavior.</p><p>NOTE: <code>ppx_minidebug</code> 3.0 requires a Unix terminal. See <a href="https://ocaml.org/p/ppx_minidebug/2.4.0">ppx_minidebug 2.4.0</a> (<a href="https://github.com/lukstafi/ppx_minidebug/tree/2.4.x-static-artifacts">2.4.x-static-artifacts branch</a>) for a version that has poor scaling because it produces pre-rendered artifacts from debugging, but is platform-independent.</p></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#quick-start">Quick Start</a><ul><li><a href="#installation">Installation</a></li><li><a href="#basic-usage">Basic Usage</a></li></ul></li><li><a href="#why-ppx_minidebug?">Why ppx_minidebug?</a></li><li><a href="#features">Features</a><ul><li><a href="#interactive-tui">Interactive TUI</a></li><li><a href="#cli-commands">CLI Commands</a></li></ul></li><li><a href="#extension-points">Extension Points</a><ul><li><a href="#%debug_*-—-standard-debugging"><code>%debug_*</code> — Standard debugging</a></li><li><a href="#%track_*-—-control-flow-tracking"><code>%track_*</code> — Control flow tracking</a></li><li><a href="#%diagn_*-—-diagnostic-logging"><code>%diagn_*</code> — Diagnostic logging</a></li></ul></li><li><a href="#runtime-configuration">Runtime Configuration</a><ul><li><a href="#basic-setup">Basic Setup</a></li><li><a href="#configuration-options">Configuration Options</a></li><li><a href="#file-versioning">File Versioning</a></li></ul></li><li><a href="#log-levels">Log Levels</a><ul><li><a href="#compile-time-filtering">Compile-time filtering</a></li><li><a href="#runtime-filtering">Runtime filtering</a></li><li><a href="#path-filtering">Path Filtering</a></li></ul></li><li><a href="#advanced-usage">Advanced Usage</a><ul><li><a href="#explicit-logging-with-%log">Explicit Logging with <code>%log</code></a></li><li><a href="#anonymous-functions-and-insufficient-annotations">Anonymous Functions and Insufficient Annotations</a></li><li><a href="#concurrent-execution">Concurrent Execution</a></li></ul></li><li><a href="#performance">Performance</a><ul><li><a href="#fast-mode-(default)">Fast Mode (Default)</a></li><li><a href="#lazy-initialization">Lazy Initialization</a></li><li><a href="#deduplication">Deduplication</a></li></ul></li><li><a href="#type-annotations">Type Annotations</a></li><li><a href="#comparison-with-legacy-backends">Comparison with Legacy Backends</a></li><li><a href="#technical-details">Technical Details</a></li><li><a href="#examples">Examples</a></li><li><a href="#related-tools">Related Tools</a></li><li><a href="#contributing">Contributing</a></li><li><a href="#license">License</a></li><li><a href="#changelog">Changelog</a></li></ul></nav></div><div class="odoc-content"><h2 id="quick-start"><a href="#quick-start" class="anchor"></a>Quick Start</h2><h3 id="installation"><a href="#installation" class="anchor"></a>Installation</h3><pre class="language-bash"><code>opam install ppx_minidebug</code></pre><h3 id="basic-usage"><a href="#basic-usage" class="anchor"></a>Basic Usage</h3><p>Add to your <code>dune</code> file:</p><pre class="language-lisp"><code>(executable
  (name my_program)
  (libraries ppx_minidebug.runtime)
  (preprocess (pps ppx_minidebug)))</code></pre><p>Instrument your code:</p><pre class="language-ocaml"><code>open Sexplib0.Sexp_conv

(* Setup database runtime *)
let _get_local_debug_runtime =
  let rt = Minidebug_db.debug_db_file &quot;my_trace&quot; in
  fun () -&gt; rt

(* Annotate functions with %debug_sexp *)
let%debug_sexp rec factorial (n : int) : int =
  if n &lt;= 1 then 1
  else n * factorial (n - 1)

let () =
  Printf.printf &quot;5! = %d\n&quot; (factorial 5)</code></pre><p>Run and explore:</p><pre class="language-bash"><code>./my_program              # Creates my_trace_1.db
minidebug_view my_trace.db tui   # Launch interactive TUI</code></pre> <img src="doc/tui-factorial-values_first.png" alt="Screenshot of TUI showing factorial trace with expanded tree"/><h2 id="why-ppx_minidebug?"><a href="#why-ppx_minidebug?" class="anchor"></a>Why ppx_minidebug?</h2><ul><li><b>Zero runtime overhead with compile-time filtering</b>: <code>[%%global_debug_log_level 0]</code> eliminates all logging code</li><li><b>Interactive exploration</b>: Navigate traces with vim-like keybindings, search with regex, auto-expand to matches</li><li><b>Efficient storage</b>: Content-addressed deduplication + recursive sexp caching minimize database size</li><li><b>Fast mode</b>: ~100x speedup with top-level transactions</li><li><b>Type-driven</b>: Only logs what you annotate — precise control over verbosity</li><li><b>Three serialization backends</b>: <code>%debug_sexp</code> (sexplib0), <code>%debug_show</code> (ppx_deriving.show), <code>%debug_pp</code> (Format)</li></ul><h2 id="features"><a href="#features" class="anchor"></a>Features</h2><h3 id="interactive-tui"><a href="#interactive-tui" class="anchor"></a>Interactive TUI</h3><p>Launch the TUI to explore your traces interactively:</p><pre class="language-bash"><code>minidebug_view trace.db tui</code></pre><p><b>Navigation:</b></p><ul><li><code>↑</code>/<code>↓</code> or <code>j</code>/<code>k</code>: Move cursor up/down</li><li><code>Home</code>/<code>End</code>: Jump to first/last entry</li><li><code>PgUp</code>/<code>PgDown</code> (or <code>Fn+↑</code>/<code>Fn+↓</code>): Page navigation</li><li><code>u</code>/<code>d</code>: Quarter-page navigation (1/4 screen)</li><li><code>Enter</code> or <code>Space</code>: Expand/collapse entry</li></ul><p><b>Search:</b></p><ul><li><code>/</code>: Open search prompt (supports 4 concurrent searches: S1-S4)</li><li><code>n</code>/<code>N</code>: Jump to next/previous match (auto-expands tree to reveal match)</li><li><code>Q</code>: Set quiet path filter (stops highlight propagation at matching ancestors)</li><li><code>o</code>: Toggle search ordering (Ascending/Descending scope_id)</li></ul><p><b>Display:</b></p><ul><li><code>t</code>: Toggle elapsed times</li><li><code>v</code>: Toggle values-first mode</li><li><code>q</code>: Quit</li></ul> <img src="doc/tui-search_results.png" alt="Screenshot showing search results with highlighted paths"/><h3 id="cli-commands"><a href="#cli-commands" class="anchor"></a>CLI Commands</h3><pre class="language-bash"><code># Show database statistics
minidebug_view trace.db stats

# Display full trace tree
minidebug_view trace.db show

# Compact view (function names + timing only)
minidebug_view trace.db compact

# Search from CLI
minidebug_view trace.db search &quot;pattern&quot;

# Export to markdown
minidebug_view trace.db export &gt; trace.md

# List top-level entries (efficient for large databases)
minidebug_view trace.db roots</code></pre><h2 id="extension-points"><a href="#extension-points" class="anchor"></a>Extension Points</h2><p><code>ppx_minidebug</code> provides three families of extension points:</p><h3 id="%debug_*-—-standard-debugging"><a href="#%debug_*-—-standard-debugging" class="anchor"></a><code>%debug_*</code> — Standard debugging</h3><p>Logs parameters, return values, and let-bound values, where type annotated:</p><pre class="language-ocaml"><code>let%debug_sexp fibonacci (n : int) : int = ...</code></pre><h3 id="%track_*-—-control-flow-tracking"><a href="#%track_*-—-control-flow-tracking" class="anchor"></a><code>%track_*</code> — Control flow tracking</h3><p>Additionally logs which branches are taken in <code>if</code>, <code>match</code>, <code>function</code>, <code>for</code>, and <code>while</code>:</p><pre class="language-ocaml"><code>let%track_sexp process_list (items : int list) : int =
  match items with  (* branch info logged *)
  | [] -&gt; 0
  | x :: xs -&gt; x + process_list xs</code></pre><h3 id="%diagn_*-—-diagnostic-logging"><a href="#%diagn_*-—-diagnostic-logging" class="anchor"></a><code>%diagn_*</code> — Diagnostic logging</h3><p>For explicit logs only (ignores function parameters/results/bindings unless explicitly logged with <code>%log</code>):</p><pre class="language-ocaml"><code>let%diagn_sexp complex_computation (x : int) : int =
  let y : int = step1 x in (* not logged despite type annotation *)
  let z : int =
    if rare_case y then ([%log &quot;found this:&quot;, (y : int)]; step_rare y) else step2 y in
  z * 2  (* result not logged *)</code></pre><p>Each family supports three serialization methods:</p><ul><li><code>%debug_sexp</code> / <code>%track_sexp</code> / <code>%diagn_sexp</code> — requires <code>ppx_sexp_conv</code></li><li><code>%debug_show</code> / <code>%track_show</code> / <code>%diagn_show</code> — requires <code>ppx_deriving.show</code></li><li><code>%debug_pp</code> / <code>%track_pp</code> / <code>%diagn_pp</code> — requires custom <code>pp</code> functions</li></ul><h2 id="runtime-configuration"><a href="#runtime-configuration" class="anchor"></a>Runtime Configuration</h2><h3 id="basic-setup"><a href="#basic-setup" class="anchor"></a>Basic Setup</h3><pre class="language-ocaml"><code>(* Single database file shared across all traces *)
let _get_local_debug_runtime =
  let rt = Minidebug_db.debug_db_file &quot;my_debug&quot; in
  fun () -&gt; rt</code></pre><p><b>Important:</b> Use the pattern <code>let rt = ... in fun () -&gt; rt</code> to ensure a single runtime instance is shared across all calls. This prevents creating multiple database files.</p><h3 id="configuration-options"><a href="#configuration-options" class="anchor"></a>Configuration Options</h3><pre class="language-ocaml"><code>let _get_local_debug_runtime =
  let rt = Minidebug_db.debug_db_file
    ~elapsed_times:Microseconds    (* Show elapsed time in microseconds *)
    ~log_level:2                    (* Only log entries at level 2 or higher *)
    ~print_scope_ids:true          (* Include scope IDs in output *)
    ~path_filter:(`Whitelist (Re.compile (Re.str &quot;my_module&quot;)))  (* Filter by path *)
    ~run_name:&quot;test_run_1&quot;         (* Name this trace run *)
    &quot;my_debug&quot;
  in
  fun () -&gt; rt</code></pre><p>Available options:</p><ul><li><code>time_tagged</code>: Clock time timestamps (Elapsed, Absolute, or Nothing)</li><li><code>elapsed_times</code>: Elapsed time precision (Seconds, Milliseconds, Microseconds, Nanoseconds)</li><li><code>location_format</code>: Source location format (File_line, File_only, No_location)</li><li><code>print_scope_ids</code>: Show scope IDs in output</li><li><code>verbose_scope_ids</code>: Show full scope ID details</li><li><code>run_name</code>: Name for this trace run (stored in metadata database)</li><li><code>log_level</code>: Minimum log level to record (0 = log everything)</li><li><code>path_filter</code>: Whitelist/Blacklist regex for file paths</li></ul><h3 id="file-versioning"><a href="#file-versioning" class="anchor"></a>File Versioning</h3><p><code>ppx_minidebug</code> automatically versions database files to prevent conflicts:</p><pre class="language-ocaml"><code>(* Three runtime instances in same process *)
let rt1 = Minidebug_db.debug_db_file &quot;trace&quot; in  (* Creates trace_1.db *)
let rt2 = Minidebug_db.debug_db_file &quot;trace&quot; in  (* Creates trace_2.db *)
let rt3 = Minidebug_db.debug_db_file &quot;trace&quot; in  (* Creates trace_3.db *)</code></pre><p>A symlink <code>trace.db</code> points to the latest versioned file. Run metadata is stored in <code>trace_meta.db</code>.</p><h2 id="log-levels"><a href="#log-levels" class="anchor"></a>Log Levels</h2><p>Control logging verbosity with compile-time and runtime log levels:</p><h3 id="compile-time-filtering"><a href="#compile-time-filtering" class="anchor"></a>Compile-time filtering</h3><pre class="language-ocaml"><code>(* Remove all logging code at compile time *)
[%%global_debug_log_level 0]

(* Only include level 2+ logs in compiled code *)
[%%global_debug_log_level 2]

(* Read level from environment variable at compile time *)
[%%global_debug_log_level_from_env_var &quot;DEBUG_LEVEL&quot;]</code></pre><p>Explicit log levels on extension points:</p><pre class="language-ocaml"><code>let%debug2_sexp verbose_function (x : int) : int = ...  (* Only logged if level &gt;= 2 *)
let%debug1_sexp normal_function (x : int) : int = ...   (* Logged if level &gt;= 1 *)</code></pre><h3 id="runtime-filtering"><a href="#runtime-filtering" class="anchor"></a>Runtime filtering</h3><pre class="language-ocaml"><code>(* Runtime log level filters what gets recorded *)
let _get_local_debug_runtime =
  let rt = Minidebug_db.debug_db_file ~log_level:2 &quot;trace&quot; in
  fun () -&gt; rt</code></pre><h3 id="path-filtering"><a href="#path-filtering" class="anchor"></a>Path Filtering</h3><p>Filter logs by file path or function name:</p><pre class="language-ocaml"><code>(* Whitelist: only log from my_module.ml *)
let _get_local_debug_runtime =
  let rt = Minidebug_db.debug_db_file
    ~path_filter:(`Whitelist (Re.compile (Re.str &quot;my_module&quot;)))
    &quot;trace&quot;
  in
  fun () -&gt; rt

(* Blacklist: exclude test utilities *)
let _get_local_debug_runtime =
  let rt = Minidebug_db.debug_db_file
    ~path_filter:(`Blacklist (Re.compile (Re.alt [
      Re.str &quot;test_utils&quot;;
      Re.str &quot;mock_&quot;
    ])))
    &quot;trace&quot;
  in
  fun () -&gt; rt

(* Filter by function name prefix *)
let _get_local_debug_runtime =
  let rt = Minidebug_db.debug_db_file
    ~path_filter:(`Whitelist (Re.compile (Re.seq [
      Re.rep Re.any;
      Re.str &quot;/process_&quot;;
      Re.rep Re.any
    ])))
    &quot;trace&quot;
  in
  fun () -&gt; rt</code></pre><p>Path filters are applied to the <code>&quot;file/function_or_binding_name&quot;</code> pattern.</p><h2 id="advanced-usage"><a href="#advanced-usage" class="anchor"></a>Advanced Usage</h2><p>See <a href="index_legacy.html"><code>index_legacy</code></a> for a more detailed description and full coverage of many features not mentioned here.</p><h3 id="explicit-logging-with-%log"><a href="#explicit-logging-with-%log" class="anchor"></a>Explicit Logging with <code>%log</code></h3><p>Log arbitrary computations explicitly, don't compute them when logging disabled:</p><pre class="language-ocaml"><code>let%debug_sexp complex_calculation (x : int) : int =
  let intermediate : int = x * 2 in      (* Logged binding *)
  [%log &quot;Let's check&quot;, (expensive_analysis intermediate : sexpable_analysis_result)];
  let result : int = intermediate + 5 in (* Logged binding *)
  result  (* Also logged as return value *)</code></pre><h3 id="anonymous-functions-and-insufficient-annotations"><a href="#anonymous-functions-and-insufficient-annotations" class="anchor"></a>Anonymous Functions and Insufficient Annotations</h3><p>Use <code>%track_*</code> to log anonymous functions and unannotated bindings:</p><pre class="language-ocaml"><code>let%track_sexp process_items (items : int list) : int list =
  List.map (fun x -&gt; x * 2) items  (* Anonymous function logged *)</code></pre><h3 id="concurrent-execution"><a href="#concurrent-execution" class="anchor"></a>Concurrent Execution</h3><p>Each thread/domain should have its own runtime instance. The recommended approach is to have a single <code>_get_local_debug_runtime</code> function which returns the runtime (first-class module) from a domain-local or thread-local storage. In more complex cases, various other options are possible, e.g.:</p><pre class="language-ocaml"><code>let create_runtime () =
  let rt = Minidebug_db.debug_db_file &quot;worker&quot; in
  fun () -&gt; rt

let worker_thread () =
  let _get_local_debug_runtime = create_runtime () in
  (* Worker code with instrumentation *)
  ...</code></pre><p>Each thread creates a separate versioned database file (<code>worker_1.db</code>, <code>worker_2.db</code>, etc.).</p><h2 id="performance"><a href="#performance" class="anchor"></a>Performance</h2><h3 id="fast-mode-(default)"><a href="#fast-mode-(default)" class="anchor"></a>Fast Mode (Default)</h3><p><code>ppx_minidebug</code> uses &quot;Fast mode&quot; by default, providing ~100x speedup over naive autocommit:</p><ul><li><b>Top-level transactions</b>: <code>BEGIN</code> when entering top-level scope, <code>COMMIT</code> when exiting</li><li><b>DELETE journal + synchronous=OFF</b>: Trades durability for speed</li><li><b>Automatic commit</b>: <code>at_exit</code> handlers and signal handlers (SIGINT, SIGTERM) ensure safe commits</li></ul><p>The database is <b>unlocked between top-level traces</b>, allowing the TUI to read while your program runs.</p><h3 id="lazy-initialization"><a href="#lazy-initialization" class="anchor"></a>Lazy Initialization</h3><p>Database files are created lazily — only when the first log is written. If all logs are filtered out (compile-time <code>log_level=0</code> or runtime filtering), no database file is created.</p><h3 id="deduplication"><a href="#deduplication" class="anchor"></a>Deduplication</h3><p>Two-level deduplication minimizes database size:</p><ul><li><b>Content-addressed value storage</b>: MD5 hash-based O(1) deduplication of logged values</li><li><b>Recursive sexp caching</b>: During boxify (large value decomposition), repeated substructures are cached and reused</li></ul><p>Example: Logging a list of 1000 identical trees stores each unique tree structure only once.</p><h2 id="type-annotations"><a href="#type-annotations" class="anchor"></a>Type Annotations</h2><p><code>ppx_minidebug</code> requires type annotations to determine how to serialize values:</p><pre class="language-ocaml"><code>(* ✓ Will be logged *)
let%debug_sexp foo (x : int) (y : string) : int = ...

(* ✗ Not logged — missing type annotations *)
let%debug_sexp bar x y = x + y</code></pre><p>For local bindings:</p><pre class="language-ocaml"><code>let%debug_sexp compute (x : int) : int =
  let y : int = x * 2 in    (* ✓ Logged *)
  let z = y + 5 in          (* ✗ Not logged — no type annotation *)
  z</code></pre><p>Tip: Add/remove type annotations to control logging granularity without changing extension points.</p><h2 id="comparison-with-legacy-backends"><a href="#comparison-with-legacy-backends" class="anchor"></a>Comparison with Legacy Backends</h2><p><code>ppx_minidebug</code> 3.0+ uses a database backend by default. Previous versions (2.x) used static HTML/Markdown/text file generation.</p><p><b>Why database backend?</b></p><ul><li>Interactive exploration with TUI (search, navigation, auto-expand)</li><li>Handles large traces (100M+ entries) efficiently</li><li>Content-addressed deduplication reduces storage</li><li>Single source of truth (no scattered HTML files)</li><li>Queryable with standard SQL tools</li></ul><p><b>Migration:</b> Change <code>Minidebug_runtime.debug_file</code> to <code>Minidebug_db.debug_db_file</code>. See <a href="README_LEGACY.md">README_LEGACY.md</a> for 2.x documentation.</p><h2 id="technical-details"><a href="#technical-details" class="anchor"></a>Technical Details</h2><ul><li><b>Database</b>: SQLite with content-addressed value storage</li><li><b>Schema</b>: Composite keys <code>(scope_id, seq_id)</code> for chronological ordering</li><li><b>TUI</b>: Built with Notty, concurrent search using OCaml Domains</li><li><b>Boxify</b>: Large sexps decomposed into nested scopes with indentation-based parsing</li><li><b>Metadata database</b>: Separate <code>*_meta.db</code> tracks runs across versioned files</li></ul><p>See <a href="DATABASE_BACKEND.md">DATABASE_BACKEND.md</a> for complete technical documentation.</p><h2 id="examples"><a href="#examples" class="anchor"></a>Examples</h2><p>See the <code>test/</code> directory for extensive examples:</p><ul><li><a href="test/test_debug_sexp.ml">test_debug_sexp.ml</a> — Basic sexp logging</li><li><a href="test/test_expect_test.ml">test_expect_test.ml</a> — Comprehensive test suite with 60+ examples</li><li><a href="test/test_path_filter.ml">test_path_filter.ml</a> — Path filtering examples</li></ul><h2 id="related-tools"><a href="#related-tools" class="anchor"></a>Related Tools</h2><ul><li><a href="https://github.com/dariusf/ppx_debug"><code>ppx_debug</code></a> — Complementary PPX with different design trade-offs</li><li><a href="https://github.com/LexiFi/landmarks">Landmarks</a> — Profiling-focused tracing</li><li><a href="https://github.com/c-cube/ocaml-trace">Ocaml-trace</a> — Tracing library with backend support</li></ul><h2 id="contributing"><a href="#contributing" class="anchor"></a>Contributing</h2><p>Contributions welcome! See <a href="CLAUDE.md">CLAUDE.md</a> for development guide.</p><h2 id="license"><a href="#license" class="anchor"></a>License</h2><p>MIT License — see <a href="LICENSE">LICENSE</a></p><h2 id="changelog"><a href="#changelog" class="anchor"></a>Changelog</h2><p>See <a href="CHANGELOG.md">CHANGELOG.md</a> for version history.</p></div></body></html>
