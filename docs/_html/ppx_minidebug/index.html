<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>index (ppx_minidebug.index)</title><meta charset="utf-8"/><link rel="stylesheet" href="../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – ppx_minidebug</nav><header class="odoc-preamble"><h1 id="ppx_minidebug"><a href="#ppx_minidebug" class="anchor"></a>ppx_minidebug</h1></header><nav class="odoc-toc"><ul><li><a href="#ppx_minidebug:-debug-logs-for-selected-functions-and-let-bindings"><code>ppx_minidebug</code>: Debug logs for selected functions and let-bindings</a><ul><li><a href="#traces-in-html-or-markdown-as-collapsible-trees">Traces in HTML or Markdown as collapsible trees</a></li><li><a href="#highlighting-search-terms">Highlighting search terms</a></li><li><a href="#printbox-creating-helpers-with-defaults:-debug-and-debug_file"><code>PrintBox</code> creating helpers with defaults: <code>debug</code> and <code>debug_file</code></a><ul><li><a href="#hyperlinks-to-source-locations">Hyperlinks to source locations</a></li></ul></li><li><a href="#recommended:-values_first_mode">Recommended: <code>values_first_mode</code></a></li></ul></li><li><a href="#usage">Usage</a><ul><li><a href="#breaking-infinite-recursion-with-max_nesting_depth-and-looping-with-max_num_children;-flushing-based-traces">Breaking infinite recursion with <code>max_nesting_depth</code> and looping with <code>max_num_children</code>; <code>Flushing</code>-based traces</a></li><li><a href="#tracking:-control-flow-branches,-anonymous-and-insufficiently-annotated-functions">Tracking: control flow branches, anonymous and insufficiently annotated functions</a></li><li><a href="#using-as-a-logging-framework">Using as a logging framework</a></li><li><a href="#lexical-scopes-vs.-dynamic-scopes">Lexical scopes vs. dynamic scopes</a></li><li><a href="#reducing-the-size-of-generated-logs">Reducing the size of generated logs</a></li><li><a href="#navigating-large-logs">Navigating large logs</a></li><li><a href="#providing-the-necessary-type-information">Providing the necessary type information</a></li><li><a href="#dealing-with-concurrent-execution">Dealing with concurrent execution</a></li></ul></li></ul></nav><div class="odoc-content"><h2 id="ppx_minidebug:-debug-logs-for-selected-functions-and-let-bindings"><a href="#ppx_minidebug:-debug-logs-for-selected-functions-and-let-bindings" class="anchor"></a><code>ppx_minidebug</code>: Debug logs for selected functions and let-bindings</h2><p><code>ppx_minidebug</code> traces let bindings and functions within a selected scope if they have type annotations. <code>ppx_minidebug</code> offers three ways of instrumenting the code: <code>%debug_pp</code> and <code>%debug_show</code> (also <code>%track_pp</code> and <code>%track_show</code>), based on <code>deriving.show</code>, and <code>%debug_sexp</code> (also <code>%track_sexp</code>) based on <code>sexplib0</code> and <code>ppx_sexp_conv</code>. Explicit logs can be added with <code>%log</code> within a debug scope (<code>%log</code> is not a registered extension point to avoid conflicts with other logging frameworks). The syntax extension expects a module <code>Debug_runtime</code> in the scope. The <code>ppx_minidebug.runtime</code> library (part of the <code>ppx_minidebug</code> package) offers multiple ways of logging the traces, as helper functions generating <code>Debug_runtime</code> modules. See <a href="https://lukstafi.github.io/ppx_minidebug/ppx_minidebug/Minidebug_runtime/index.html">the generated documentation for <code>Minidebug_runtime</code></a>.</p><p>Take a look at <a href="https://github.com/dariusf/ppx_debug"><code>ppx_debug</code></a> which has complementary strengths!</p><p>Try <code>opam install ppx_minidebug</code> to install from the opam repository. To install the development version of <code>ppx_minidebug</code>, download it with e.g. <code>gh repo clone lukstafi/ppx_minidebug; cd ppx_minidebug</code> and then <code>dune build; opam install .</code>.</p><p>To use <code>ppx_minidebug</code> in a Dune project, add/modify these stanzas: <code>(preprocess (pps ... ppx_minidebug))</code>, and <code>(libraries ... ppx_minidebug.runtime)</code>.</p><p>Here we define a <code>Debug_runtime</code> either using the entrypoint <code>module Debug_runtime = (val Minidebug_runtime.debug ())</code>, or using the <code>PrintBox</code> functor, e.g.:</p><pre class="language-ocaml"><code>module Debug_runtime =
  Minidebug_runtime.PrintBox((val Minidebug_runtime.debug_ch &quot;path/to/debugger_printbox.log&quot; end))</code></pre><p>The logged traces will be pretty-printed as trees using the <code>printbox</code> package. Truncated example (using <code>%debug_sexp</code>):</p><pre class="language-shell"><code>BEGIN DEBUG SESSION
&quot;test/test_debug_sexp.ml&quot;:7:19-9:17: foo
├─x = 7
├─&quot;test/test_debug_sexp.ml&quot;:8:6: y
│ └─y = 8
└─foo = (7 8 16)
&quot;test/test_debug_sexp.ml&quot;:15:19-17:14: bar
├─x = ((first 7) (second 42))
├─&quot;test/test_debug_sexp.ml&quot;:16:6: y
│ └─y = 8
└─bar = 336
&quot;test/test_debug_sexp.ml&quot;:21:19-24:28: baz
├─x = ((first 7) (second 42))
├─&quot;test/test_debug_sexp.ml&quot;:22:17: _yz
│ └─_yz = (8 3)
├─&quot;test/test_debug_sexp.ml&quot;:23:17: _uw
│ └─_uw = (7 13)
└─baz = 359
&quot;test/test_debug_sexp.ml&quot;:28:19-30:17: lab
├─x = 7
├─&quot;test/test_debug_sexp.ml&quot;:29:6: y
│ └─y = 8
└─lab = (7 8 16)
&quot;test/test_debug_sexp.ml&quot;:34:24-40:9: loop
├─depth = 0
├─x = ((first 7) (second 42))
├─&quot;test/test_debug_sexp.ml&quot;:38:8: y
│ ├─&quot;test/test_debug_sexp.ml&quot;:34:24-40:9: loop
│ │ ├─depth = 1
│ │ ├─x = ((first 41) (second 9))
│ │ ├─&quot;test/test_debug_sexp.ml&quot;:38:8: y
│ │ │ ├─&quot;test/test_debug_sexp.ml&quot;:34:24-40:9: loop
│ │ │ │ ├─depth = 2
│ │ │ │ ├─x = ((first 8) (second 43))
│ │ │ │ ├─&quot;test/test_debug_sexp.ml&quot;:34:24-40:9: loop
│ │ │ │ │ ├─depth = 3
│ │ │ │ │ ├─x = ((first 44) (second 4))
│ │ │ │ │ ├─&quot;test/test_debug_sexp.ml&quot;:34:24-40:9: loop
│ │ │ │ │ │ ├─depth = 4
│ │ │ │ │ │ ├─x = ((first 5) (second 22))
│ │ │ │ │ │ ├─&quot;test/test_debug_sexp.ml&quot;:34:24-40:9: loop
│ │ │ │ │ │ │ ├─depth = 5
│ │ │ │ │ │ │ ├─x = ((first 23) (second 2))
│ │ │ │ │ │ │ └─loop = 25</code></pre><h3 id="traces-in-html-or-markdown-as-collapsible-trees"><a href="#traces-in-html-or-markdown-as-collapsible-trees" class="anchor"></a>Traces in HTML or Markdown as collapsible trees</h3><p>The <code>PrintBox</code> runtime can be configured to output logs using HTML or Markdown. The logs then become collapsible trees, so that you can expose only the relevant information when debugging. Example configuration:</p><pre class="language-ocaml"><code>module Debug_runtime =
  Minidebug_runtime.PrintBox ((val Minidebug_runtime.debug_ch &quot;debug.html&quot;))
let () = Debug_runtime.(html_config := `Html default_html_config)
let () = Debug_runtime.boxify_sexp_from_size := 50</code></pre><p>Here we also convert the logged <code>sexp</code> values (with at least 50 atoms) to trees. Example result:  <img src="docs/ppx_minidebug-foldable_trees.png" alt="PrintBox runtime with collapsible/foldable trees"/></p><h3 id="highlighting-search-terms"><a href="#highlighting-search-terms" class="anchor"></a>Highlighting search terms</h3><p>The <code>PrintBox</code> runtime also supports highlighting paths to logs that match a <code>highlight_terms</code> regular expression. For example:  <img src="docs/ppx_minidebug-highlight_term_169.png" alt="PrintBox runtime with collapsible/foldable trees"/></p><p>To limit the highlight noise, some log entries can be excluded from propagating the highlight status using the <code>exclude_on_path</code> setting. To trim excessive logging while still providing some context, you can set <code>prune_upto</code> to a level greater than 0, which only outputs highlighted boxes below that level.</p><h3 id="printbox-creating-helpers-with-defaults:-debug-and-debug_file"><a href="#printbox-creating-helpers-with-defaults:-debug-and-debug_file" class="anchor"></a><code>PrintBox</code> creating helpers with defaults: <code>debug</code> and <code>debug_file</code></h3><p>The configuration for the above example is more concisely just:</p><pre class="language-ocaml"><code>module Debug_runtime = (val Minidebug_runtime.debug_file ~highlight_terms:(Re.str &quot;169&quot;) &quot;debug&quot;)</code></pre><p>Similarly, <code>debug</code> returns a <code>PrintBox</code> module, which by default logs to <code>stdout</code>:</p><pre class="language-ocaml"><code>module Debug_runtime = (val Minidebug_runtime.debug ())</code></pre><h4 id="hyperlinks-to-source-locations"><a href="#hyperlinks-to-source-locations" class="anchor"></a>Hyperlinks to source locations</h4><p>The HTML output supports emitting file locations as hyperlinks. For example:</p><pre class="language-ocaml"><code>module Debug_runtime = (val Minidebug_runtime.debug_file ~hyperlink:&quot;&quot; &quot;debug&quot;)</code></pre><p>where <code>~hyperlink</code> is the prefix to let you tune the file path and select a browsing option. For illustration, the prefixes for Markdown / HTML outputs I might use at the time of writing:</p><ul><li><code>~hyperlink:&quot;./&quot;</code> or <code>~hyperlink:&quot;../&quot;</code> depending on the relative locations of the log file and the binary</li><li><p><code>~hyperlink:&quot;vscode://file//wsl.localhost/ubuntu23/home/lukstafi/ppx_minidebug/&quot;</code></p><ul><li>if left-clicking a link from within VS Code Live Preview follows the file in the HTML preview window rather than an editor window, middle-click the link</li></ul></li><li><code>~hyperlink:&quot;https://github.com/lukstafi/ppx_minidebug/tree/main/&quot;</code></li></ul><h3 id="recommended:-values_first_mode"><a href="#recommended:-values_first_mode" class="anchor"></a>Recommended: <code>values_first_mode</code></h3><p>This setting puts the result of the computation as the header of a computation subtree, rather than the source code location of the computation. I recommend using this setting as it reduces noise and makes the important information easier to find and visible with less unfolding. Another important benefit is that it makes hyperlinks usable, by pushing them from the summary line to under the fold. I decided to not make it the default setting, because it is not available in the bare-bones runtimes, and can be confusing.</p><p>For example:</p><pre class="language-ocaml"><code>module Debug_runtime =
  (val Minidebug_runtime.debug ~highlight_terms:(Re.str &quot;3&quot;) ~values_first_mode:true ())
let%debug_this_show rec loop_highlight (x : int) : int =
  let z : int = (x - 1) / 2 in
  if x &lt;= 0 then 0 else z + loop_highlight (z + (x / 2))
let () = print_endline @@ Int.to_string @@ loop_highlight 7</code></pre><p>Truncated results:</p><pre class="language-shell"><code>BEGIN DEBUG SESSION
┌──────────────────┐
│loop_highlight = 9│
├──────────────────┘
├─&quot;test/test_expect_test.ml&quot;:1042:41-1044:58
├─x = 7
├─┬─────┐
│ │z = 3│
│ ├─────┘
│ └─&quot;test/test_expect_test.ml&quot;:1043:8
└─┬──────────────────┐
  │loop_highlight = 6│
  ├──────────────────┘
  ├─&quot;test/test_expect_test.ml&quot;:1042:41-1044:58
  ├─x = 6
  ├─z = 2
  │ └─&quot;test/test_expect_test.ml&quot;:1043:8
  └─┬──────────────────┐
    │loop_highlight = 4│
    ├──────────────────┘
    ├─&quot;test/test_expect_test.ml&quot;:1042:41-1044:58</code></pre><p>When logging uses sexps and boxification, and the result is decomposed into a subtree, only the header of the result subtree is put in the header line, and the rest of the result subtree is just underneath it with a <code>&lt;returns&gt;</code> or a <code>&lt;values&gt;</code> header. Example showcasing the <code>printbox-html</code> backend:  <img src="docs/ppx_minidebug-html-hyperlink.png" alt="PrintBox HTML backend -- follow hyperlink"/></p><p>Example showcasing the <code>printbox-md</code> (Markdown) backend:  <img src="docs/ppx_minidebug-md-hyperlink.png" alt="PrintBox Markdown backend -- follow hyperlink"/></p><h2 id="usage"><a href="#usage" class="anchor"></a>Usage</h2><p>Tracing only happens in explicitly marked lexical scopes. The entry extension points vary along four axes:</p><ul><li><p><code>%debug_</code> vs. <code>%track_</code> vs. <code>%diagn_</code></p><ul><li>The prefix <code>%debug_</code> means logging fewer things: only let-bound values and functions are logged, and functions only when either: directly in a <code>%debug_</code>-annotated let binding, or their return type is annotated.</li><li><code>%track_</code> also logs: which <code>if</code>, <code>match</code>, <code>function</code> branch is taken, <code>for</code> and <code>while</code> loops, and all functions, including anonymous ones.</li><li>The prefix <code>%diagn_</code> means only generating logs for explicitly logged values, i.e. introduced by <code>[%log ...]</code> statements.</li></ul></li><li><p>Optional infix <code>_this_</code> puts only the body of a <code>let</code> definition in scope for logging.</p><ul><li><code>let%debug_this_show v: t = compute value in outer scope</code> will trace <code>v</code> and the type-annotated bindings and functions inside <code>compute value</code>, but it will not trace <code>outer scope</code>.</li></ul></li><li><p>Optional infixes <code>_rt_</code> and <code>_rtb_</code> add a first-class module argument to a function, and unpack it as <code>module Debug_runtime</code> for the scope of the function.</p><ul><li><code>_rt_</code> uses the module type <code>Minidebug_runtime.Debug_runtime</code>.</li><li><code>_rtb_</code> uses the module type <code>Minidebug_runtime.PrintBox_runtime</code>.</li><li>This functionality is &quot;one use only&quot;: it applies only to the function the extension point is attached to.</li></ul></li><li><p>Representation and printing mechanism: <code>_pp</code>, <code>_show</code>, recommended: <code>_sexp</code></p><ul><li><code>_pp</code> is currently most restrictive as it requires the type of a value to be an identifier. The identifier is converted to a <code>pp_</code> printing function, e.g. <code>pp_int</code>.</li><li><code>_show</code> converts values to strings via the <code>%show</code> extension provided by <code>deriving.show</code>: e.g. <code>[%show: int list]</code>.</li><li><code>_sexp</code> converts values to sexp expressions first using <code>%sexp_of</code>, e.g. <code>[%sexp_of: int list]</code>. The runtime can decide how to print the sexp expressions. The <code>PrintBox</code> backend allows to convert the sexps to box structures first, with the <code>boxify_sexp_from_size</code> setting. This means large values can be unfolded gradually for inspection.</li></ul></li></ul><p>Plus, there is a non-entry extension point <code>%log</code> for logging values. It is not registered, which as a side effect should somewhat mitigate conflicts with other ppx extensions for logging.</p><p>See examples in <a href="test/">the test directory</a>, and especially <a href="test/test_expect_test.ml">the inline tests</a>.</p><p>Only type-annotated let-bindings, function arguments, function results can be (implicitly) logged. However, the bindings and function arguments can be nested patterns with only parts of them type-annotated! The explicit logger <code>%log</code> takes a value (an expression that can be re-parsed as a pattern) and reconstructs its type from partial type annotations, sometimes assuming unknown types are strings.</p><p>To properly trace in concurrent settings, ensure that different threads use different log channels. For example, you can bind <code>Debug_runtime</code> locally: <code>let module Debug_runtime = Minidebug_runtime.debug_file thread_name in ...</code></p><p><code>ppx_minidebug</code> can be installed using <code>opam</code>. <code>ppx_minidebug.runtime</code> depends on <code>printbox</code>, <code>ptime</code>, <code>mtime</code>, <code>sexplib0</code>.</p><h3 id="breaking-infinite-recursion-with-max_nesting_depth-and-looping-with-max_num_children;-flushing-based-traces"><a href="#breaking-infinite-recursion-with-max_nesting_depth-and-looping-with-max_num_children;-flushing-based-traces" class="anchor"></a>Breaking infinite recursion with <code>max_nesting_depth</code> and looping with <code>max_num_children</code>; <code>Flushing</code>-based traces</h3><p>The <code>PrintBox</code> backend only produces any output when a top-level log entry gets closed. This makes it harder to debug infinite loops and especially infinite recursion. The setting <code>max_nesting_depth</code> terminates a computation when the given log nesting is exceeded. For example:</p><pre class="language-ocaml"><code>module Debug_runtime = (val Minidebug_runtime.debug ())

let%debug_show rec loop_exceeded (x : int) : int =
  [%debug_interrupts
    { max_nesting_depth = 5; max_num_children = 1000 };
    let z : int = (x - 1) / 2 in
    if x &lt;= 0 then 0 else z + loop_exceeded (z + (x / 2))]

let () =
  try print_endline @@ Int.to_string @@ loop_exceeded 17
  with _ -&gt; print_endline &quot;Raised exception.&quot;</code></pre><p>Similarly, <code>max_num_children</code> raises a failure when the given number of logs with the same parent is exceeded. For example:</p><pre class="language-ocaml"><code>module Debug_runtime = (val Minidebug_runtime.debug ())

let%debug_show _bar : unit =
  [%debug_interrupts
    { max_nesting_depth = 1000; max_num_children = 10 };
    for i = 0 to 100 do
      let _baz : int = i * 2 in
      ()
    done]</code></pre><p>The <code>%debug_interrupts</code> extension point emits the interrupt checks in a lexically delimited scope. For convenience, we offer the extension point <code>%global_debug_interrupts</code> which triggers emitting the interrupt checks in the remainder of the source preprocessed in the same process (its scope is therefore less well defined). For example:</p><pre class="language-ocaml"><code>module Debug_runtime = (val Minidebug_runtime.debug ())

[%%global_debug_interrupts { max_nesting_depth = 5; max_num_children = 10 }]

let%debug_show rec loop_exceeded (x : int) : int =
  let z : int = (x - 1) / 2 in
  if x &lt;= 0 then 0 else z + loop_exceeded (z + (x / 2))

let () =
  try print_endline @@ Int.to_string @@ loop_exceeded 17
  with _ -&gt; print_endline &quot;Raised exception.&quot;

let%track_show bar () : unit =
  for i = 0 to 100 do
    let _baz : int = i * 2 in
    ()
  done

let () = try bar () with _ -&gt; print_endline &quot;Raised exception.&quot;</code></pre><p>If that is insufficient, you can define a <code>Debug_runtime</code> using the <code>Flushing</code> functor. E.g. either <code>module Debug_runtime = (val Minidebug_runtime.debug_flushing ())</code>, or:</p><pre class="language-ocaml"><code>module Debug_runtime =
  Minidebug_runtime.Flushing((val Minidebug_runtime.debug_ch &quot;path/to/debugger_flushing.log&quot;))</code></pre><p>The logged traces are still indented, but if the values to print are multi-line, their formatting might be messy. The benefit of <code>Flushing</code> traces is that the output is flushed line-at-a-time, so no output should be lost if the traced program crashes. But in recent versions of <code>ppx_minidebug</code>, uncaught exceptions no longer break logging in the <code>PrintBox</code> runtime. The indentation is also smaller (half of <code>PrintBox</code>). Truncated example (using <code>%debug_show</code>):</p><pre class="language-shell"><code>BEGIN DEBUG SESSION at time 2023-03-02 23:19:40.763950 +01:00
2023-03-02 23:19:40.763980 +01:00 - foo begin &quot;test/test_debug_show.ml&quot;:3:19-5:15
 x = 7
 foo = [7; 8; 16]
2023-03-02 23:19:40.764000 +01:00 - foo end
2023-03-02 23:19:40.764011 +01:00 - bar begin &quot;test/test_debug_show.ml&quot;:10:19-10:73
 x = { Test_debug_show.first = 7; second = 42 }
 bar = 336
2023-03-02 23:19:40.764028 +01:00 - bar end
2023-03-02 23:19:40.764034 +01:00 - baz begin &quot;test/test_debug_show.ml&quot;:13:19-14:67
 x = { Test_debug_show.first = 7; second = 42 }
 baz = 339
2023-03-02 23:19:40.764048 +01:00 - baz end
2023-03-02 23:19:40.764054 +01:00 - loop begin &quot;test/test_debug_show.ml&quot;:17:24-23:9
 depth = 0
 x = { Test_debug_show.first = 7; second = 42 }
  &quot;test/test_debug_show.ml&quot;:21:8: 
  2023-03-02 23:19:40.764073 +01:00 - loop begin &quot;test/test_debug_show.ml&quot;:17:24-23:9
   depth = 1
   x = { Test_debug_show.first = 41; second = 9 }
    &quot;test/test_debug_show.ml&quot;:21:8: 
    2023-03-02 23:19:40.764094 +01:00 - loop begin &quot;test/test_debug_show.ml&quot;:17:24-23:9
     depth = 2
     x = { Test_debug_show.first = 8; second = 43 }
      &quot;test/test_debug_show.ml&quot;:21:8: 
      2023-03-02 23:19:40.764109 +01:00 - loop begin &quot;test/test_debug_show.ml&quot;:17:24-23:9
       depth = 3
       x = { Test_debug_show.first = 42; second = 10 }
        &quot;test/test_debug_show.ml&quot;:21:8: </code></pre><h3 id="tracking:-control-flow-branches,-anonymous-and-insufficiently-annotated-functions"><a href="#tracking:-control-flow-branches,-anonymous-and-insufficiently-annotated-functions" class="anchor"></a>Tracking: control flow branches, anonymous and insufficiently annotated functions</h3><p>Using the <code>%track_</code>-prefix rather than <code>%debug_</code>-prefix to start a debug scope, or using the <code>%debug_trace</code> extension point inside a debug scope, enables more elaborate tracking of the execution path. It logs which <code>if</code>, <code>match</code>, <code>function</code> branch is taken. It logs the nesting and loop index of <code>for</code> loops, and the nesting of <code>while</code> loops. It logs functions even if the return type is not annotated, including anonymous functions; in particular, it logs type-annotated arguments of anonymous functions. To selectively disable these logs, use <code>%debug_notrace</code>. Note that it disables the logs on a lexical scope, not just on the annotated syntax node (e.g. a specific <code>if</code> or <code>match</code> expression).</p><p>If you get fewer logs than you expected, try converting <code>%debug_</code> to <code>%track_</code>.</p><p>For example:</p><pre class="language-ocaml"><code>let%track_show track_branches (x : int) : int =
  if x &lt; 6 then
    match%debug_notrace x with
    | 0 -&gt; 1
    | 1 -&gt; 0
    | _ -&gt;
        let result : int = if x &gt; 2 then x else ~-x in
        result
  else
    match x with
    | 6 -&gt; 5
    | 7 -&gt; 4
    | _ -&gt;
        let result : int = if x &lt; 10 then x else ~-x in
        result

let () =
  print_endline @@ Int.to_string @@ track_branches 8;
  print_endline @@ Int.to_string @@ track_branches 3</code></pre><p>gives:</p><pre class="language-shell"><code>BEGIN DEBUG SESSION
&quot;test/test_expect_test.ml&quot;:415:37-429:16: track_branches
├─x = 8
├─&quot;test/test_expect_test.ml&quot;:424:6: &lt;if -- else branch&gt;
│ └─&quot;test/test_expect_test.ml&quot;:427:8: &lt;match -- branch 2&gt;
│   └─&quot;test/test_expect_test.ml&quot;:428:14: result
│     ├─&quot;test/test_expect_test.ml&quot;:428:44: &lt;if -- then branch&gt;
│     └─result = 8
└─track_branches = 8
8
&quot;test/test_expect_test.ml&quot;:415:37-429:16: track_branches
├─x = 3
├─&quot;test/test_expect_test.ml&quot;:417:6: &lt;if -- then branch&gt;
│ └─&quot;test/test_expect_test.ml&quot;:421:14: result
│   └─result = 3
└─track_branches = 3
3</code></pre><p>and</p><pre class="language-ocaml"><code>let%track_this_show anonymous (x : int) =
  Array.fold_left ( + ) 0 @@ Array.init (x + 1) (fun (i : int) -&gt; i)
in
print_endline @@ Int.to_string @@ anonymous 3</code></pre><p>gives:</p><pre class="language-shell"><code>BEGIN DEBUG SESSION
&quot;test/test_expect_test.ml&quot;:516:32-517:70: anonymous
├─x = 3
├─&quot;test/test_expect_test.ml&quot;:517:50-517:70: __fun
│ └─i = 0
├─&quot;test/test_expect_test.ml&quot;:517:50-517:70: __fun
│ └─i = 1
├─&quot;test/test_expect_test.ml&quot;:517:50-517:70: __fun
│ └─i = 2
└─&quot;test/test_expect_test.ml&quot;:517:50-517:70: __fun
  └─i = 3
6</code></pre><p>Explicit logging statements also help with tracking the execution, since they can be placed anywhere within a debug scope. Example from the test suite:</p><pre class="language-ocaml"><code>let module Debug_runtime = (val Minidebug_runtime.debug ()) in
let%track_sexp result =
  let i = ref 0 in
  let j = ref 0 in
  while !i &lt; 6 do
    [%log 1, &quot;i=&quot;, (!i : int)];
    incr i;
    [%log 2, &quot;i=&quot;, (!i : int)];
    j := !j + !i;
    [%log 3, &quot;j=&quot;, (!j : int)]
  done;
  !j
in
print_endline @@ Int.to_string result;
[%expect
  {|
  BEGIN DEBUG SESSION
  &quot;test/test_expect_test.ml&quot;:2271:4: &lt;while loop&gt;
  ├─&quot;test/test_expect_test.ml&quot;:2272:6: &lt;while loop&gt;
  │ ├─(1 i= 0)
  │ ├─(2 i= 1)
  │ └─(3 j= 1)
  ├─&quot;test/test_expect_test.ml&quot;:2272:6: &lt;while loop&gt;
  │ ├─(1 i= 1)
  │ ├─(2 i= 2)
  │ └─(3 j= 3)
  ├─&quot;test/test_expect_test.ml&quot;:2272:6: &lt;while loop&gt;
  │ ├─(1 i= 2)
  │ ├─(2 i= 3)
  │ └─(3 j= 6)
  ├─&quot;test/test_expect_test.ml&quot;:2272:6: &lt;while loop&gt;
  │ ├─(1 i= 3)
  │ ├─(2 i= 4)
  │ └─(3 j= 10)
  ├─&quot;test/test_expect_test.ml&quot;:2272:6: &lt;while loop&gt;
  │ ├─(1 i= 4)
  │ ├─(2 i= 5)
  │ └─(3 j= 15)
  └─&quot;test/test_expect_test.ml&quot;:2272:6: &lt;while loop&gt;
    ├─(1 i= 5)
    ├─(2 i= 6)
    └─(3 j= 21)
  21
      |}]</code></pre><h3 id="using-as-a-logging-framework"><a href="#using-as-a-logging-framework" class="anchor"></a>Using as a logging framework</h3><p><code>ppx_minidebug</code> can be used as a logging framework: its annotations can be stored permamently with the source code, rather than shyly added for a brief period of debugging. To allow this, there needs to be a mechanism of logging levels -- otherwise the system is slowed down too much, or even if performance is not an issue, the user is overwhelmed with the amount of logs. <code>ppx_minidebug</code> addresses these issues in a flexible way, by offering restriction of log levels both at compile time and at runtime.</p><p>The <code>%diagn_</code> extension points (short for &quot;diagnostic&quot;) are tailored for the &quot;logging framework&quot; use-case. Within the scope of a <code>%diagn_</code> extension point, only explicit logs are generated. Therefore, one can freely add type annotations without generating debug logs.</p><p>In the <code>PrintBox</code> backend, logs accumulate until the current toplevel log scope is closed. This is unfortunate in the logging framework context, where promptly informing the user using the logs might be important. To remedy this, <code>PrintBox_runtime</code> offers the setting <code>snapshot_every_sec</code>. When set, if sufficient time has passed since the last output, the backend will output the whole current toplevel log scope. If possible, the previous snapshot of the same log scope is erased, to not duplicate information.</p><p>The log levels are:</p><ul><li><code>Nothing</code> -- the runtime should not generate anything, and when used at compile time, the extension should not generate any <code>ppx_minidebug</code>-related code. However, just changing the log level should not break the code, therefore the runtime-passing transformation (i.e. the first-class-module argument added by the <code>_rt_</code> and <code>_rtb_</code> infixes) happens even for the <code>Nothing</code> log level.</li><li><code>Prefixed [| prefix1; ... |]</code> -- only values starting with one of: prefix1, ... should be logged; at compile time, only logs with literals having one of prefix1, ... as a prefix, should be generated. Moreover, also don't log &quot;empty entries&quot; (see below). To preserve the hierarchical context, also log headers of logging scopes.</li><li><code>Prefixed_or_result [| prefix1; ... |]</code> as above, but also log results of computations. At runtime doesn't output results of an entry if there are no non-result logs.</li><li><code>Prefixed [||]</code> is compile-time only -- outputs all and only explicit logs (i.e. <code>%log</code> statements).</li><li><code>Prefixed_or_result [||]</code> at compile-time -- as above, but also log results of computations.</li><li><code>Prefixed_or_result [||]</code> at runtime -- only log results of computations if an entry has non-result logs.</li><li><code>Nonempty_entries</code> -- do not log entries, such as functions or control flow blocks, that do not have sub-logs.</li><li><code>Everything</code> -- no restrictions.</li></ul><p>The <code>%diagn_</code> extension points are a shorthand for setting the compile-time log level to <code>Prefixed [||]</code>. Example from the test suite:</p><pre class="language-ocaml"><code>let module Debug_runtime = (val Minidebug_runtime.debug ~values_first_mode:true ()) in
let%diagn_show bar { first : int; second : int } : int =
  let { first : int = a; second : int = b } = { first; second = second + 3 } in
  let y : int = a + 1 in
  [%log &quot;for bar, b-3&quot;, (b - 3 : int)];
  (b - 3) * y
in
let () = print_endline @@ Int.to_string @@ bar { first = 7; second = 42 } in
let baz { first : int; second : int } : int =
  let { first : int; second : int } = { first = first + 1; second = second + 3 } in
  [%log &quot;for baz, f squared&quot;, (first * first : int)];
  (first * first) + second
in
let () = print_endline @@ Int.to_string @@ baz { first = 7; second = 42 } in
[%expect
  {|
    BEGIN DEBUG SESSION
    bar
    ├─&quot;test/test_expect_test.ml&quot;:2972:21-2976:15
    └─(&quot;for bar, b-3&quot;, 42)
    336
    baz
    ├─&quot;test/test_expect_test.ml&quot;:2979:10-2982:28
    └─(&quot;for baz, f squared&quot;, 64)
    109 |}]</code></pre><p>At runtime, the level can be set via <code>Minidebug_runtime.debug ~log_level</code> or <code>Minidebug_runtime.debug_file ~log_level</code> at runtime creation, or via <code>Debug_runtime.config.log_level &lt;- ...</code> later on. Check out the test suite <a href="test/test_expect_test.ml#L2439">test_expect_test.ml:&quot;%log runtime log levels while-loop&quot;</a> for examples:</p><pre class="language-ocaml"><code>let%track_rtb_sexp result () : int =
  let i = ref 0 in
  let j = ref 0 in
  while !i &lt; 6 do
    (* Intentional empty but not omitted else-branch. *)
    if !i &lt; 2 then [%log &quot;ERROR:&quot;, 1, &quot;i=&quot;, (!i : int)] else ();
    incr i;
    [%log &quot;WARNING:&quot;, 2, &quot;i=&quot;, (!i : int)];
    j := (fun { contents } -&gt; !j + contents) i;
    [%log &quot;INFO:&quot;, 3, &quot;j=&quot;, (!j : int)]
  done;
  !j
in
...
print_endline
@@ Int.to_string
     (result
        (Minidebug_runtime.debug ~values_first_mode:true ~log_level:Nonempty_entries
           ~global_prefix:&quot;Nonempty&quot; ())
        ());
...</code></pre><p>At compile time, the level can be set for a scope with <code>%log_level</code>, or globally with <code>%global_debug_log_level</code>. (<code>%log_level</code> is not registered to minimize incompatibility with other logging frameworks.) For example:</p><pre class="language-ocaml"><code>[%%global_log_level Nonempty_entries]

let%track_sexp nonempty () : int =
  let i = ref 0 in
  let j = ref 0 in
  while !i &lt; 6 do
    (* Intentional empty but not omitted else-branch. *)
    if !i &lt; 2 then [%log &quot;ERROR:&quot;, 1, &quot;i=&quot;, (!i : int)] else ();
    incr i;
    [%log &quot;WARNING:&quot;, 2, &quot;i=&quot;, (!i : int)];
    j := (fun { contents } -&gt; !j + contents) i;
    [%log &quot;INFO:&quot;, 3, &quot;j=&quot;, (!j : int)]
  done;
  !j

let () = print_endline @@ Int.to_string @@ nonempty ()</code></pre><p>With some &quot;abuse of notation&quot;, we use <code>Prefixed [||]</code> resp. <code>Prefixed_or_result [||]</code> to mean all-and-only explicit logs (resp. also result logs). <code>Prefixed [||]</code> only works at compile time. <code>Prefixed_or_result [||]</code> works as intended when set both at compile time and at runtime: then, it will output all explicit logs, but also results in otherwise-nonempty entries. Example from the test suite:</p><pre class="language-ocaml"><code>let module Debug_runtime =
  (val Minidebug_runtime.debug ~values_first_mode:true
         ~log_level:(Prefixed_or_result [||]) ())
in
let%debug_show () =
  [%log_level
    Prefixed_or_result [||];
    let bar { first : int; second : int } : int =
      let { first : int = a; second : int = b } = { first; second = second + 3 } in
      let y : int = a + 1 in
      [%log &quot;for bar, b-3&quot;, (b - 3 : int)];
      (b - 3) * y
    in
    let baz { first : int; second : int } : int =
      let { first : int; second : int } = { first = first + 1; second = second + 3 } in
      [%log &quot;for baz, f squared&quot;, (first * first : int)];
      (first * first) + second
    in
    print_endline @@ Int.to_string @@ bar { first = 7; second = 42 };
    print_endline @@ Int.to_string @@ baz { first = 7; second = 42 }]
in
[%expect
  {|
      BEGIN DEBUG SESSION
      bar = 336
      ├─&quot;test/test_expect_test.ml&quot;:3073:14-3077:19
      └─(&quot;for bar, b-3&quot;, 42)
      336
      baz = 109
      ├─&quot;test/test_expect_test.ml&quot;:3079:14-3082:32
      └─(&quot;for baz, f squared&quot;, 64)
      109 |}]</code></pre><h3 id="lexical-scopes-vs.-dynamic-scopes"><a href="#lexical-scopes-vs.-dynamic-scopes" class="anchor"></a>Lexical scopes vs. dynamic scopes</h3><p>We track lexical scoping: every log has access to the <code>entry_id</code> number of the lexical scope it is in. Lexical scopes are computations: bindings, functions, tracked code branches (even if not annotated with an extension point, but always within some <code>ppx_minidebug</code> registered extension point). There is also dynamic scoping: which entry a particular log actually ends up belonging in. Currently, we do not expose the (lexical) entry id of an individual log, except when the log &quot;wandered&quot; out of all dynamic scopes. To be able to locate where such log originates from, pass <code>~print_entry_ids:true</code> when creating the runtime, and look for the header with the log's entry id. Example from the test suite:</p><pre class="language-ocaml"><code>let module Debug_runtime =
  (val Minidebug_runtime.debug ~print_entry_ids:true ~values_first_mode:true ())
in
let i = 3 in
let pi = 3.14 in
let l = [ 1; 2; 3 ] in
(* Messing with the structure of the logs might lead to confusing output. *)
let foo1 = ref @@ fun () -&gt; () in
let foo2 = ref @@ fun () -&gt; () in
let%debug_show bar callback : unit =
  foo1 :=
    fun () -&gt;
      [%log &quot;This is like&quot;, (i : int), &quot;or&quot;, (pi : float), &quot;above&quot;];
      [%log &quot;tau =&quot;, (pi *. 2. : float)];
      callback ()
in
let%debug_show baz callback : unit =
  foo2 :=
    fun () -&gt;
      [%log i :: (l : int list)];
      [%log (i : int) :: l];
      callback ()
in
let () =
  bar !foo2;
  baz !foo1;
  bar !foo2
in
let () = !foo2 () in
[%expect
  {|
        BEGIN DEBUG SESSION
        bar = ()
        └─&quot;test/test_expect_test.ml&quot;:2923:21-2928:19: {#1}
        baz = ()
        └─&quot;test/test_expect_test.ml&quot;:2930:21-2935:19: {#2}
        bar = ()
        └─&quot;test/test_expect_test.ml&quot;:2923:21-2928:19: {#3}
        [3; 1; 2; 3]
        └─{orphaned from #2}
        [3; 1; 2; 3]
        └─{orphaned from #2}
        (&quot;This is like&quot;, 3, &quot;or&quot;, 3.14, &quot;above&quot;)
        └─{orphaned from #1}
        (&quot;tau =&quot;, 6.28)
        └─{orphaned from #1} |}]</code></pre><h3 id="reducing-the-size-of-generated-logs"><a href="#reducing-the-size-of-generated-logs" class="anchor"></a>Reducing the size of generated logs</h3><p>Summary of possibilities:</p><ul><li>log levels</li><li><code>no_debug_if</code></li><li><code>prune_upto</code></li><li><code>truncate_children</code></li><li><code>split_files_after</code></li><li>HTML browsers can handle really large files (less luck with Markdown).</li></ul><p>The log levels discussed in the previous section certainly reduce the amount generated, but they either help too little (<code>Nonempty_entries</code>) or they remove logs too indiscriminately (<code>Prefixed</code>) for use in a debugging context. Dynamically controlling the runtime log level is one option, but there are some other options.</p><p>In the PrintBox backend, you can disable the logging of specified subtrees, when the output is irrelevant, would be a distraction, or the logs take up too much space. The test suite example:</p><pre class="language-ocaml"><code>let%debug_this_show rec fixpoint_changes (x: int): int =
  let z: int = (x - 1) / 2 in
  (* The call [x = 2] is not printed because it is a descendant of
     the no-debug call [x = 4]. *)
  Debug_runtime.no_debug_if (x &lt;&gt; 6 &amp;&amp; x &lt;&gt; 2 &amp;&amp; (z + 1) * 2 = x);
  if x &lt;= 0 then 0 else z + fixpoint_changes (z + x / 2) in
print_endline @@ Int.to_string @@ fixpoint_changes 7</code></pre><p>leads to:</p><pre class="language-shell"><code>&quot;test/test_expect_test.ml&quot;:96:43-100:58: fixpoint_changes
├─x = 7
├─&quot;test/test_expect_test.ml&quot;:97:8: z
│ └─z = 3
├─&quot;test/test_expect_test.ml&quot;:96:43-100:58: fixpoint_changes
│ ├─x = 6
│ ├─&quot;test/test_expect_test.ml&quot;:97:8: z
│ │ └─z = 2
│ ├─&quot;test/test_expect_test.ml&quot;:96:43-100:58: fixpoint_changes
│ │ ├─x = 5
│ │ ├─&quot;test/test_expect_test.ml&quot;:97:8: z
│ │ │ └─z = 2
│ │ └─fixpoint_changes = 4
│ └─fixpoint_changes = 6
└─fixpoint_changes = 9
9</code></pre><p>The <code>no_debug_if</code> mechanism requires modifying the logged sources, and since it's limited to cutting out subtrees of the logs, it can be tricky to select and preserve the context one wants. The highlighting mechanism with the <code>prune_upto</code> setting avoids these problems. You provide a search term without modifying the debugged sources. You can tune the pruning level to keep the context around the place the search term was found.</p><p>Setting the option <code>truncate_children</code> will only log the given number of children at each node, prioritizing the most recent ones. An example from the test suite:</p><pre class="language-ocaml"><code>let module Debug_runtime = (val Minidebug_runtime.debug ~truncate_children:10 ()) in
let () =
  let%track_this_show _bar : unit =
    for i = 0 to 30 do
      let _baz : int = i * 2 in
      ()
    done
  in
  ()
in
[%expect
  {|
  BEGIN DEBUG SESSION
  &quot;test/test_expect_test.ml&quot;:350:26: _bar
  ├─&quot;test/test_expect_test.ml&quot;:351:8: &lt;for loop&gt;
  │ ├─&lt;earlier entries truncated&gt;
  │ ├─i = 26
  │ ├─&quot;test/test_expect_test.ml&quot;:351:12: &lt;for i&gt;
  │ │ └─&quot;test/test_expect_test.ml&quot;:352:14: _baz
  │ │   └─_baz = 52
  │ ├─i = 27
  │ ├─&quot;test/test_expect_test.ml&quot;:351:12: &lt;for i&gt;
  │ │ └─&quot;test/test_expect_test.ml&quot;:352:14: _baz
  │ │   └─_baz = 54
  │ ├─i = 28
  │ ├─&quot;test/test_expect_test.ml&quot;:351:12: &lt;for i&gt;
  │ │ └─&quot;test/test_expect_test.ml&quot;:352:14: _baz
  │ │   └─_baz = 56
  │ ├─i = 29
  │ ├─&quot;test/test_expect_test.ml&quot;:351:12: &lt;for i&gt;
  │ │ └─&quot;test/test_expect_test.ml&quot;:352:14: _baz
  │ │   └─_baz = 58
  │ ├─i = 30
  │ └─&quot;test/test_expect_test.ml&quot;:351:12: &lt;for i&gt;
  │   └─&quot;test/test_expect_test.ml&quot;:352:14: _baz
  │     └─_baz = 60
  └─_bar = () |}]</code></pre><p>If you provide the <code>split_files_after</code> setting, the logging will transition to a new file after the current file exceeds the given number of characters. However, the splits only happen at the &quot;toplevel&quot;, to not interrupt laying out the log trees. If required, you can remove logging indicators from your high-level functions, to bring the deeper logic log trees to the toplevel. This matters when you prefer Markdown output over HTML output -- in my experience, Markdown renderers (VS Code Markdown Preview, GitHub Preview) fail for files larger than 2MB, while browsers easily handle HTML files of over 200MB (including via VS Code Live Preview).</p><h3 id="navigating-large-logs"><a href="#navigating-large-logs" class="anchor"></a>Navigating large logs</h3><p>In the future, <code>ppx_minidebug</code> will have native flame graphs in the HTML output (issue #19), which will then serve as a &quot;table of contents&quot; for the logs. Currently the best option to navigate large logs is to use the HTML backend with foldable trees and <code>elapsed_times</code> set. Unlike with the Markdown backend, HTML browsers can render really large files.</p><p>Example:</p><pre class="language-ocaml"><code>module Debug_runtime =
  (val Minidebug_runtime.debug_file ~elapsed_times:Microseconds ~hyperlink:&quot;./&quot;
         ~backend:(`Markdown Minidebug_runtime.default_md_config) ~values_first_mode:true
         ~truncate_children:4 &quot;debugger_sexp_time_spans&quot;)

let sexp_of_int i = Sexplib0.Sexp.Atom (string_of_int i)

let () =
  let%debug_sexp rec loop (x : int) : int =
    Array.fold_left ( + ) 0
    @@ Array.init
         (20 / (x + 1))
         (fun i -&gt;
           let z : int = i + ((x - 1) / 2) in
           if x &lt;= 0 then i else i + loop (z + (x / 2) - i))
  in
  print_endline @@ Int.to_string @@ loop 3</code></pre><p>Inlined example output, using the Markdown backend for PrintBox. Note that the elapsed time is wallclock time (see <a href="https://erratique.ch/software/mtime"><code>mtime</code></a>) and is due to fluctuate because of e.g. garbage collection or external system events.</p><p>BEGIN DEBUG SESSION &lt;details&gt;&lt;summary&gt;&lt;code&gt;loop = 58435&lt;/code&gt; &amp;nbsp; &amp;lt;16850.93μs&amp;gt;&lt;/summary&gt;</p><ul><li><a href="./test/test_debug_time_spans.ml#L9">&quot;test/test_debug_time_spans.ml&quot;:9:26-15:60</a></li><li>&lt;earlier entries truncated&gt;</li><li><p>&lt;details&gt;&lt;summary&gt;&lt;code&gt;z = 4&lt;/code&gt; &amp;nbsp; &amp;lt;0.50μs&amp;gt;&lt;/summary&gt;</p><ul><li><a href="./test/test_debug_time_spans.ml#L14">&quot;test/test_debug_time_spans.ml&quot;:14:15</a></li></ul><p>&lt;/details&gt;</p></li><li><p>&lt;details&gt;&lt;summary&gt;&lt;code&gt;loop = 11685&lt;/code&gt; &amp;nbsp; &amp;lt;3111.59μs&amp;gt;&lt;/summary&gt;</p><ul><li><a href="./test/test_debug_time_spans.ml#L9">&quot;test/test_debug_time_spans.ml&quot;:9:26-15:60</a></li><li>&lt;earlier entries truncated&gt;</li><li><p>&lt;details&gt;&lt;summary&gt;&lt;code&gt;z = 4&lt;/code&gt; &amp;nbsp; &amp;lt;0.48μs&amp;gt;&lt;/summary&gt;</p><ul><li><a href="./test/test_debug_time_spans.ml#L14">&quot;test/test_debug_time_spans.ml&quot;:14:15</a></li></ul><p>&lt;/details&gt;</p></li><li><p>&lt;details&gt;&lt;summary&gt;&lt;code&gt;loop = 1945&lt;/code&gt; &amp;nbsp; &amp;lt;494.56μs&amp;gt;&lt;/summary&gt;</p><ul><li><a href="./test/test_debug_time_spans.ml#L9">&quot;test/test_debug_time_spans.ml&quot;:9:26-15:60</a></li><li>&lt;earlier entries truncated&gt;</li><li><p>&lt;details&gt;&lt;summary&gt;&lt;code&gt;z = 8&lt;/code&gt; &amp;nbsp; &amp;lt;0.48μs&amp;gt;&lt;/summary&gt;</p><ul><li><a href="./test/test_debug_time_spans.ml#L14">&quot;test/test_debug_time_spans.ml&quot;:14:15</a></li></ul><p>&lt;/details&gt;</p></li><li><p>&lt;details&gt;&lt;summary&gt;&lt;code&gt;loop = 190&lt;/code&gt; &amp;nbsp; &amp;lt;41.60μs&amp;gt;&lt;/summary&gt;</p><ul><li><a href="./test/test_debug_time_spans.ml#L9">&quot;test/test_debug_time_spans.ml&quot;:9:26-15:60</a></li><li>&lt;earlier entries truncated&gt;</li><li><p>&lt;details&gt;&lt;summary&gt;&lt;code&gt;z = 16&lt;/code&gt; &amp;nbsp; &amp;lt;0.41μs&amp;gt;&lt;/summary&gt;</p><ul><li><a href="./test/test_debug_time_spans.ml#L14">&quot;test/test_debug_time_spans.ml&quot;:14:15</a></li></ul><p>&lt;/details&gt;</p></li><li><p>&lt;details&gt;&lt;summary&gt;&lt;code&gt;z = 17&lt;/code&gt; &amp;nbsp; &amp;lt;0.42μs&amp;gt;&lt;/summary&gt;</p><ul><li><a href="./test/test_debug_time_spans.ml#L14">&quot;test/test_debug_time_spans.ml&quot;:14:15</a></li></ul><p>&lt;/details&gt;</p></li><li><p>&lt;details&gt;&lt;summary&gt;&lt;code&gt;z = 18&lt;/code&gt; &amp;nbsp; &amp;lt;0.45μs&amp;gt;&lt;/summary&gt;</p><ul><li><a href="./test/test_debug_time_spans.ml#L14">&quot;test/test_debug_time_spans.ml&quot;:14:15</a></li></ul><p>&lt;/details&gt;</p></li><li><p>&lt;details&gt;&lt;summary&gt;&lt;code&gt;z = 19&lt;/code&gt; &amp;nbsp; &amp;lt;0.45μs&amp;gt;&lt;/summary&gt;</p><ul><li><a href="./test/test_debug_time_spans.ml#L14">&quot;test/test_debug_time_spans.ml&quot;:14:15</a></li></ul><p>&lt;/details&gt;</p></li></ul><p>&lt;/details&gt;</p></li><li><p>&lt;details&gt;&lt;summary&gt;&lt;code&gt;z = 9&lt;/code&gt; &amp;nbsp; &amp;lt;0.49μs&amp;gt;&lt;/summary&gt;</p><ul><li><a href="./test/test_debug_time_spans.ml#L14">&quot;test/test_debug_time_spans.ml&quot;:14:15</a></li></ul><p>&lt;/details&gt;</p></li><li><p>&lt;details&gt;&lt;summary&gt;&lt;code&gt;loop = 190&lt;/code&gt; &amp;nbsp; &amp;lt;41.54μs&amp;gt;&lt;/summary&gt;</p><ul><li><a href="./test/test_debug_time_spans.ml#L9">&quot;test/test_debug_time_spans.ml&quot;:9:26-15:60</a></li><li>&lt;earlier entries truncated&gt;</li><li><p>&lt;details&gt;&lt;summary&gt;&lt;code&gt;z = 16&lt;/code&gt; &amp;nbsp; &amp;lt;0.42μs&amp;gt;&lt;/summary&gt;</p><ul><li><a href="./test/test_debug_time_spans.ml#L14">&quot;test/test_debug_time_spans.ml&quot;:14:15</a></li></ul><p>&lt;/details&gt;</p></li><li><p>&lt;details&gt;&lt;summary&gt;&lt;code&gt;z = 17&lt;/code&gt; &amp;nbsp; &amp;lt;0.45μs&amp;gt;&lt;/summary&gt;</p><ul><li><a href="./test/test_debug_time_spans.ml#L14">&quot;test/test_debug_time_spans.ml&quot;:14:15</a></li></ul><p>&lt;/details&gt;</p></li><li><p>&lt;details&gt;&lt;summary&gt;&lt;code&gt;z = 18&lt;/code&gt; &amp;nbsp; &amp;lt;0.41μs&amp;gt;&lt;/summary&gt;</p><ul><li><a href="./test/test_debug_time_spans.ml#L14">&quot;test/test_debug_time_spans.ml&quot;:14:15</a></li></ul><p>&lt;/details&gt;</p></li><li><p>&lt;details&gt;&lt;summary&gt;&lt;code&gt;z = 19&lt;/code&gt; &amp;nbsp; &amp;lt;0.45μs&amp;gt;&lt;/summary&gt;</p><ul><li><a href="./test/test_debug_time_spans.ml#L14">&quot;test/test_debug_time_spans.ml&quot;:14:15</a></li></ul><p>&lt;/details&gt;</p></li></ul><p>&lt;/details&gt;</p></li></ul><p>&lt;/details&gt;</p></li><li><p>&lt;details&gt;&lt;summary&gt;&lt;code&gt;z = 5&lt;/code&gt; &amp;nbsp; &amp;lt;0.45μs&amp;gt;&lt;/summary&gt;</p><ul><li><a href="./test/test_debug_time_spans.ml#L14">&quot;test/test_debug_time_spans.ml&quot;:14:15</a></li></ul><p>&lt;/details&gt;</p></li><li><p>&lt;details&gt;&lt;summary&gt;&lt;code&gt;loop = 1945&lt;/code&gt; &amp;nbsp; &amp;lt;524.86μs&amp;gt;&lt;/summary&gt;</p><ul><li><a href="./test/test_debug_time_spans.ml#L9">&quot;test/test_debug_time_spans.ml&quot;:9:26-15:60</a></li><li>&lt;earlier entries truncated&gt;</li><li><p>&lt;details&gt;&lt;summary&gt;&lt;code&gt;z = 8&lt;/code&gt; &amp;nbsp; &amp;lt;0.46μs&amp;gt;&lt;/summary&gt;</p><ul><li><a href="./test/test_debug_time_spans.ml#L14">&quot;test/test_debug_time_spans.ml&quot;:14:15</a></li></ul><p>&lt;/details&gt;</p></li><li><p>&lt;details&gt;&lt;summary&gt;&lt;code&gt;loop = 190&lt;/code&gt; &amp;nbsp; &amp;lt;42.11μs&amp;gt;&lt;/summary&gt;</p><ul><li><a href="./test/test_debug_time_spans.ml#L9">&quot;test/test_debug_time_spans.ml&quot;:9:26-15:60</a></li><li>&lt;earlier entries truncated&gt;</li><li><p>&lt;details&gt;&lt;summary&gt;&lt;code&gt;z = 16&lt;/code&gt; &amp;nbsp; &amp;lt;0.45μs&amp;gt;&lt;/summary&gt;</p><ul><li><a href="./test/test_debug_time_spans.ml#L14">&quot;test/test_debug_time_spans.ml&quot;:14:15</a></li></ul><p>&lt;/details&gt;</p></li><li><p>&lt;details&gt;&lt;summary&gt;&lt;code&gt;z = 17&lt;/code&gt; &amp;nbsp; &amp;lt;0.45μs&amp;gt;&lt;/summary&gt;</p><ul><li><a href="./test/test_debug_time_spans.ml#L14">&quot;test/test_debug_time_spans.ml&quot;:14:15</a></li></ul><p>&lt;/details&gt;</p></li><li><p>&lt;details&gt;&lt;summary&gt;&lt;code&gt;z = 18&lt;/code&gt; &amp;nbsp; &amp;lt;0.45μs&amp;gt;&lt;/summary&gt;</p><ul><li><a href="./test/test_debug_time_spans.ml#L14">&quot;test/test_debug_time_spans.ml&quot;:14:15</a></li></ul><p>&lt;/details&gt;</p></li><li><p>&lt;details&gt;&lt;summary&gt;&lt;code&gt;z = 19&lt;/code&gt; &amp;nbsp; &amp;lt;0.42μs&amp;gt;&lt;/summary&gt;</p><ul><li><a href="./test/test_debug_time_spans.ml#L14">&quot;test/test_debug_time_spans.ml&quot;:14:15</a></li></ul><p>&lt;/details&gt;</p></li></ul><p>&lt;/details&gt;</p></li><li><p>&lt;details&gt;&lt;summary&gt;&lt;code&gt;z = 9&lt;/code&gt; &amp;nbsp; &amp;lt;0.47μs&amp;gt;&lt;/summary&gt;</p><ul><li><a href="./test/test_debug_time_spans.ml#L14">&quot;test/test_debug_time_spans.ml&quot;:14:15</a></li></ul><p>&lt;/details&gt;</p></li><li><p>&lt;details&gt;&lt;summary&gt;&lt;code&gt;loop = 190&lt;/code&gt; &amp;nbsp; &amp;lt;42.85μs&amp;gt;&lt;/summary&gt;</p><ul><li><a href="./test/test_debug_time_spans.ml#L9">&quot;test/test_debug_time_spans.ml&quot;:9:26-15:60</a></li><li>&lt;earlier entries truncated&gt;</li><li><p>&lt;details&gt;&lt;summary&gt;&lt;code&gt;z = 16&lt;/code&gt; &amp;nbsp; &amp;lt;0.43μs&amp;gt;&lt;/summary&gt;</p><ul><li><a href="./test/test_debug_time_spans.ml#L14">&quot;test/test_debug_time_spans.ml&quot;:14:15</a></li></ul><p>&lt;/details&gt;</p></li><li><p>&lt;details&gt;&lt;summary&gt;&lt;code&gt;z = 17&lt;/code&gt; &amp;nbsp; &amp;lt;0.43μs&amp;gt;&lt;/summary&gt;</p><ul><li><a href="./test/test_debug_time_spans.ml#L14">&quot;test/test_debug_time_spans.ml&quot;:14:15</a></li></ul><p>&lt;/details&gt;</p></li><li><p>&lt;details&gt;&lt;summary&gt;&lt;code&gt;z = 18&lt;/code&gt; &amp;nbsp; &amp;lt;0.45μs&amp;gt;&lt;/summary&gt;</p><ul><li><a href="./test/test_debug_time_spans.ml#L14">&quot;test/test_debug_time_spans.ml&quot;:14:15</a></li></ul><p>&lt;/details&gt;</p></li><li><p>&lt;details&gt;&lt;summary&gt;&lt;code&gt;z = 19&lt;/code&gt; &amp;nbsp; &amp;lt;0.42μs&amp;gt;&lt;/summary&gt;</p><ul><li><a href="./test/test_debug_time_spans.ml#L14">&quot;test/test_debug_time_spans.ml&quot;:14:15</a></li></ul><p>&lt;/details&gt;</p></li></ul><p>&lt;/details&gt;</p></li></ul><p>&lt;/details&gt;</p></li></ul><p>&lt;/details&gt;</p></li><li><p>&lt;details&gt;&lt;summary&gt;&lt;code&gt;z = 5&lt;/code&gt; &amp;nbsp; &amp;lt;0.44μs&amp;gt;&lt;/summary&gt;</p><ul><li><a href="./test/test_debug_time_spans.ml#L14">&quot;test/test_debug_time_spans.ml&quot;:14:15</a></li></ul><p>&lt;/details&gt;</p></li><li><p>&lt;details&gt;&lt;summary&gt;&lt;code&gt;loop = 11685&lt;/code&gt; &amp;nbsp; &amp;lt;3166.55μs&amp;gt;&lt;/summary&gt;</p><ul><li><a href="./test/test_debug_time_spans.ml#L9">&quot;test/test_debug_time_spans.ml&quot;:9:26-15:60</a></li><li>&lt;earlier entries truncated&gt;</li><li><p>&lt;details&gt;&lt;summary&gt;&lt;code&gt;z = 4&lt;/code&gt; &amp;nbsp; &amp;lt;0.49μs&amp;gt;&lt;/summary&gt;</p><ul><li><a href="./test/test_debug_time_spans.ml#L14">&quot;test/test_debug_time_spans.ml&quot;:14:15</a></li></ul><p>&lt;/details&gt;</p></li><li><p>&lt;details&gt;&lt;summary&gt;&lt;code&gt;loop = 1945&lt;/code&gt; &amp;nbsp; &amp;lt;499.49μs&amp;gt;&lt;/summary&gt;</p><ul><li><a href="./test/test_debug_time_spans.ml#L9">&quot;test/test_debug_time_spans.ml&quot;:9:26-15:60</a></li><li>&lt;earlier entries truncated&gt;</li><li><p>&lt;details&gt;&lt;summary&gt;&lt;code&gt;z = 8&lt;/code&gt; &amp;nbsp; &amp;lt;0.50μs&amp;gt;&lt;/summary&gt;</p><ul><li><a href="./test/test_debug_time_spans.ml#L14">&quot;test/test_debug_time_spans.ml&quot;:14:15</a></li></ul><p>&lt;/details&gt;</p></li><li><p>&lt;details&gt;&lt;summary&gt;&lt;code&gt;loop = 190&lt;/code&gt; &amp;nbsp; &amp;lt;41.51μs&amp;gt;&lt;/summary&gt;</p><ul><li><a href="./test/test_debug_time_spans.ml#L9">&quot;test/test_debug_time_spans.ml&quot;:9:26-15:60</a></li><li>&lt;earlier entries truncated&gt;</li><li><p>&lt;details&gt;&lt;summary&gt;&lt;code&gt;z = 16&lt;/code&gt; &amp;nbsp; &amp;lt;0.42μs&amp;gt;&lt;/summary&gt;</p><ul><li><a href="./test/test_debug_time_spans.ml#L14">&quot;test/test_debug_time_spans.ml&quot;:14:15</a></li></ul><p>&lt;/details&gt;</p></li><li><p>&lt;details&gt;&lt;summary&gt;&lt;code&gt;z = 17&lt;/code&gt; &amp;nbsp; &amp;lt;0.46μs&amp;gt;&lt;/summary&gt;</p><ul><li><a href="./test/test_debug_time_spans.ml#L14">&quot;test/test_debug_time_spans.ml&quot;:14:15</a></li></ul><p>&lt;/details&gt;</p></li><li><p>&lt;details&gt;&lt;summary&gt;&lt;code&gt;z = 18&lt;/code&gt; &amp;nbsp; &amp;lt;0.42μs&amp;gt;&lt;/summary&gt;</p><ul><li><a href="./test/test_debug_time_spans.ml#L14">&quot;test/test_debug_time_spans.ml&quot;:14:15</a></li></ul><p>&lt;/details&gt;</p></li><li><p>&lt;details&gt;&lt;summary&gt;&lt;code&gt;z = 19&lt;/code&gt; &amp;nbsp; &amp;lt;0.42μs&amp;gt;&lt;/summary&gt;</p><ul><li><a href="./test/test_debug_time_spans.ml#L14">&quot;test/test_debug_time_spans.ml&quot;:14:15</a></li></ul><p>&lt;/details&gt;</p></li></ul><p>&lt;/details&gt;</p></li><li><p>&lt;details&gt;&lt;summary&gt;&lt;code&gt;z = 9&lt;/code&gt; &amp;nbsp; &amp;lt;0.49μs&amp;gt;&lt;/summary&gt;</p><ul><li><a href="./test/test_debug_time_spans.ml#L14">&quot;test/test_debug_time_spans.ml&quot;:14:15</a></li></ul><p>&lt;/details&gt;</p></li><li><p>&lt;details&gt;&lt;summary&gt;&lt;code&gt;loop = 190&lt;/code&gt; &amp;nbsp; &amp;lt;41.39μs&amp;gt;&lt;/summary&gt;</p><ul><li><a href="./test/test_debug_time_spans.ml#L9">&quot;test/test_debug_time_spans.ml&quot;:9:26-15:60</a></li><li>&lt;earlier entries truncated&gt;</li><li><p>&lt;details&gt;&lt;summary&gt;&lt;code&gt;z = 16&lt;/code&gt; &amp;nbsp; &amp;lt;0.41μs&amp;gt;&lt;/summary&gt;</p><ul><li><a href="./test/test_debug_time_spans.ml#L14">&quot;test/test_debug_time_spans.ml&quot;:14:15</a></li></ul><p>&lt;/details&gt;</p></li><li><p>&lt;details&gt;&lt;summary&gt;&lt;code&gt;z = 17&lt;/code&gt; &amp;nbsp; &amp;lt;0.41μs&amp;gt;&lt;/summary&gt;</p><ul><li><a href="./test/test_debug_time_spans.ml#L14">&quot;test/test_debug_time_spans.ml&quot;:14:15</a></li></ul><p>&lt;/details&gt;</p></li><li><p>&lt;details&gt;&lt;summary&gt;&lt;code&gt;z = 18&lt;/code&gt; &amp;nbsp; &amp;lt;0.45μs&amp;gt;&lt;/summary&gt;</p><ul><li><a href="./test/test_debug_time_spans.ml#L14">&quot;test/test_debug_time_spans.ml&quot;:14:15</a></li></ul><p>&lt;/details&gt;</p></li><li><p>&lt;details&gt;&lt;summary&gt;&lt;code&gt;z = 19&lt;/code&gt; &amp;nbsp; &amp;lt;0.46μs&amp;gt;&lt;/summary&gt;</p><ul><li><a href="./test/test_debug_time_spans.ml#L14">&quot;test/test_debug_time_spans.ml&quot;:14:15</a></li></ul><p>&lt;/details&gt;</p></li></ul><p>&lt;/details&gt;</p></li></ul><p>&lt;/details&gt;</p></li><li><p>&lt;details&gt;&lt;summary&gt;&lt;code&gt;z = 5&lt;/code&gt; &amp;nbsp; &amp;lt;0.45μs&amp;gt;&lt;/summary&gt;</p><ul><li><a href="./test/test_debug_time_spans.ml#L14">&quot;test/test_debug_time_spans.ml&quot;:14:15</a></li></ul><p>&lt;/details&gt;</p></li><li><p>&lt;details&gt;&lt;summary&gt;&lt;code&gt;loop = 1945&lt;/code&gt; &amp;nbsp; &amp;lt;642.73μs&amp;gt;&lt;/summary&gt;</p><ul><li><a href="./test/test_debug_time_spans.ml#L9">&quot;test/test_debug_time_spans.ml&quot;:9:26-15:60</a></li><li>&lt;earlier entries truncated&gt;</li><li><p>&lt;details&gt;&lt;summary&gt;&lt;code&gt;z = 8&lt;/code&gt; &amp;nbsp; &amp;lt;0.47μs&amp;gt;&lt;/summary&gt;</p><ul><li><a href="./test/test_debug_time_spans.ml#L14">&quot;test/test_debug_time_spans.ml&quot;:14:15</a></li></ul><p>&lt;/details&gt;</p></li><li><p>&lt;details&gt;&lt;summary&gt;&lt;code&gt;loop = 190&lt;/code&gt; &amp;nbsp; &amp;lt;210.44μs&amp;gt;&lt;/summary&gt;</p><ul><li><a href="./test/test_debug_time_spans.ml#L9">&quot;test/test_debug_time_spans.ml&quot;:9:26-15:60</a></li><li>&lt;earlier entries truncated&gt;</li><li><p>&lt;details&gt;&lt;summary&gt;&lt;code&gt;z = 16&lt;/code&gt; &amp;nbsp; &amp;lt;167.41μs&amp;gt;&lt;/summary&gt;</p><ul><li><a href="./test/test_debug_time_spans.ml#L14">&quot;test/test_debug_time_spans.ml&quot;:14:15</a></li></ul><p>&lt;/details&gt;</p></li><li><p>&lt;details&gt;&lt;summary&gt;&lt;code&gt;z = 17&lt;/code&gt; &amp;nbsp; &amp;lt;0.53μs&amp;gt;&lt;/summary&gt;</p><ul><li><a href="./test/test_debug_time_spans.ml#L14">&quot;test/test_debug_time_spans.ml&quot;:14:15</a></li></ul><p>&lt;/details&gt;</p></li><li><p>&lt;details&gt;&lt;summary&gt;&lt;code&gt;z = 18&lt;/code&gt; &amp;nbsp; &amp;lt;0.43μs&amp;gt;&lt;/summary&gt;</p><ul><li><a href="./test/test_debug_time_spans.ml#L14">&quot;test/test_debug_time_spans.ml&quot;:14:15</a></li></ul><p>&lt;/details&gt;</p></li><li><p>&lt;details&gt;&lt;summary&gt;&lt;code&gt;z = 19&lt;/code&gt; &amp;nbsp; &amp;lt;0.43μs&amp;gt;&lt;/summary&gt;</p><ul><li><a href="./test/test_debug_time_spans.ml#L14">&quot;test/test_debug_time_spans.ml&quot;:14:15</a></li></ul><p>&lt;/details&gt;</p></li></ul><p>&lt;/details&gt;</p></li><li><p>&lt;details&gt;&lt;summary&gt;&lt;code&gt;z = 9&lt;/code&gt; &amp;nbsp; &amp;lt;0.50μs&amp;gt;&lt;/summary&gt;</p><ul><li><a href="./test/test_debug_time_spans.ml#L14">&quot;test/test_debug_time_spans.ml&quot;:14:15</a></li></ul><p>&lt;/details&gt;</p></li><li><p>&lt;details&gt;&lt;summary&gt;&lt;code&gt;loop = 190&lt;/code&gt; &amp;nbsp; &amp;lt;42.02μs&amp;gt;&lt;/summary&gt;</p><ul><li><a href="./test/test_debug_time_spans.ml#L9">&quot;test/test_debug_time_spans.ml&quot;:9:26-15:60</a></li><li>&lt;earlier entries truncated&gt;</li><li><p>&lt;details&gt;&lt;summary&gt;&lt;code&gt;z = 16&lt;/code&gt; &amp;nbsp; &amp;lt;0.43μs&amp;gt;&lt;/summary&gt;</p><ul><li><a href="./test/test_debug_time_spans.ml#L14">&quot;test/test_debug_time_spans.ml&quot;:14:15</a></li></ul><p>&lt;/details&gt;</p></li><li><p>&lt;details&gt;&lt;summary&gt;&lt;code&gt;z = 17&lt;/code&gt; &amp;nbsp; &amp;lt;0.46μs&amp;gt;&lt;/summary&gt;</p><ul><li><a href="./test/test_debug_time_spans.ml#L14">&quot;test/test_debug_time_spans.ml&quot;:14:15</a></li></ul><p>&lt;/details&gt;</p></li><li><p>&lt;details&gt;&lt;summary&gt;&lt;code&gt;z = 18&lt;/code&gt; &amp;nbsp; &amp;lt;0.42μs&amp;gt;&lt;/summary&gt;</p><ul><li><a href="./test/test_debug_time_spans.ml#L14">&quot;test/test_debug_time_spans.ml&quot;:14:15</a></li></ul><p>&lt;/details&gt;</p></li><li><p>&lt;details&gt;&lt;summary&gt;&lt;code&gt;z = 19&lt;/code&gt; &amp;nbsp; &amp;lt;0.42μs&amp;gt;&lt;/summary&gt;</p><ul><li><a href="./test/test_debug_time_spans.ml#L14">&quot;test/test_debug_time_spans.ml&quot;:14:15</a></li></ul><p>&lt;/details&gt;</p></li></ul><p>&lt;/details&gt;</p></li></ul><p>&lt;/details&gt;</p></li></ul><p>&lt;/details&gt;</p></li></ul><p>&lt;/details&gt;</p><h3 id="providing-the-necessary-type-information"><a href="#providing-the-necessary-type-information" class="anchor"></a>Providing the necessary type information</h3><p>We only implicitly log values of identifiers, located inside patterns, for which the type is provided in the source code, in a syntactically close / related location. PPX rewriters do not have access to the results of type inference. We extract the available type information, but we don't do it perfectly. We propagate type information top-down, merging it, but we do not unify or substitute type variables.</p><p>Here is a probably incomplete list of the restrictions:</p><ul><li>When types for a (sub) pattern are specified in multiple places, they are combined by matching syntactically, the type variable alternatives are discarded. The type that is closer to the (sub) pattern is preferred, even if selecting a corresponding type in another place would be better.</li><li><p>When faced with a binding of a form: <code>let pattern = (expression : type_)</code>, we make use of <code>type_</code>, but we ignore all types nested inside <code>expression</code>, even if we decompose <code>pattern</code>.</p><ul><li>For example, <code>let%track_sexp (x, y) = ((5, 3) : int * int)</code> works -- logs both <code>x</code> and <code>y</code>. Also work: <code>let%track_sexp ((x, y) : int * int) = (5, 3)</code> and <code>let%track_sexp ((x : int), (y : int)) = (5, 3)</code>. But <code>let%track_sexp (x, y) = ((5 : int), (3 : int))</code> will not log anything!</li></ul></li><li><p>We ignore record and variant datatypes when processing record and variant constructor cases. That's because there is no generic(*) way to extract the types of the arguments.</p><ul><li>(*) Although polymorphic variant types can be provided inline, we decided it's not worth the effort supporting them.</li><li><p>We do handle tuple types and the builtin array type (they are not records or variants).</p><ul><li>For example, this works: <code>let%track_sexp { first : int; second : int } = { first = 3; second =7 }</code> -- but compare with the tuple examples above, the alternatives provided above would not work for records.</li></ul></li><li>Hard-coded special cases: we do decompose the option type and the list type. For example: <code>let%track_show f : int option -&gt; unit = function None -&gt; () | Some _x -&gt; () in f (Some 3)</code> will log the value of <code>_x</code>.</li></ul></li><li><p>Another example of only propagating types top-down:</p><ul><li><code>let%track_show f (l : int option) : int = match l with Some y -&gt; ...</code> will not log <code>y</code> when <code>f</code> is applied (but it will log <code>l</code>).</li><li>Both <code>let%track_show f : int option -&gt; int = function Some y -&gt; ...</code> and <code>let%track_show f l : int = match (l : int option) with Some y -&gt; ...</code> <em>will</em> log <code>y</code>.</li></ul></li><li>We try reconstructing or guessing the types of expressions logged with <code>%log</code>, see details below.</li></ul><p>As a help in debugging whether the right type information got propagated, we offer the extension <code>%debug_type_info</code> (and <code>%global_debug_type_info</code>). (The display strips module qualifiers from types.) <code>%debug_type_info</code> is not an entry extension point (<code>%global_debug_type_info</code> is). Example <a href="test/test_expect_test.ml">from the test suite</a>:</p><pre class="language-ocaml"><code>let module Debug_runtime = (val Minidebug_runtime.debug ~values_first_mode:true ()) in
[%debug_show
  [%debug_type_info
    let f : 'a. 'a -&gt; int -&gt; int = fun _a b -&gt; b + 1 in
    let g : 'a. 'a -&gt; int -&gt; 'a -&gt; 'a -&gt; int = fun _a b _c _d -&gt; b * 2 in
    let () = print_endline @@ Int.to_string @@ f 'a' 6 in
    print_endline @@ Int.to_string @@ g 'a' 6 'b' 'c']];
[%expect
  {|
    BEGIN DEBUG SESSION
    f : int = 7
    ├─&quot;test/test_expect_test.ml&quot;:1446:37-1446:54
    └─b : int = 6
    7
    g : int = 12
    ├─&quot;test/test_expect_test.ml&quot;:1447:49-1447:72
    └─b : int = 6
    12 |}]</code></pre><p>You can also use at the module level: <code>[%%global_debug_type_info true]</code>, prior to the code of interest.</p><p>Explicit logging with <code>%log</code> has different but related restrictions compared to logging of let or argument bindings. We reconstruct the type of the expression from partial type information, where in addition to type annotations we take into account: string, int and float literals, tuple, array, list, and <code>lazy</code> expresssions. We do not analyze applications, nor constructors other than &quot;nil&quot; <code>[]</code> and &quot;cons&quot; <code>::</code> for lists. When a type is unknown, for the whole expression and for a tuple element we assume the type <code>string</code>. We don't assume string for direct subexpressions of arrays, lists, and <code>lazy</code>.</p><h3 id="dealing-with-concurrent-execution"><a href="#dealing-with-concurrent-execution" class="anchor"></a>Dealing with concurrent execution</h3><p>For programs with threads or domains running concurrently, you need to ensure that each thread uses its own instance of a debug runtime, writing to its own log file. Currently, <code>ppx_minidebug</code> doesn't do any checks to prevent abuse: using the same debug runtime instance from multiple threads or opening the same file by multiple debug runtime instances.</p><p>We offer two helpers for dealing with multiple debug runtimes. There is an optional runtime instance-level setting <code>global_prefix</code>, which adds the given information to all log headers coming from the instance.</p><p>Another feature is the extension points <code>%debug_rtb_sexp</code>, <code>%debug_this_rtb_sexp</code>, <code>%track_rtb_sexp</code>, etc. They add a first-class module argument to a function, and unpack the argument as <code>module Debug_runtime</code>. The feature helps using a runtime instance dedicated to a thread. At present, passing of the runtime instance to functions needs to be done manually. Note that only the function attached to the <code>_rt_</code> or <code>_rtb_</code> extension point is modified, regardless of whether there is a <code>_this_</code>.</p><p>Example from the test suite:</p><pre class="language-ocaml"><code>let%track_rtb_show foo l : int =
  match (l : int list) with [] -&gt; 7 | y :: _ -&gt; y * 2
in
let () =
  print_endline @@ Int.to_string
  @@ foo
       (Minidebug_runtime.debug ~global_prefix:&quot;foo-1&quot; ~values_first_mode:true ())
       [ 7 ]
in
let%track_rtb_show baz : int list -&gt; int = function
  | [] -&gt; 7
  | [ y ] -&gt; y * 2
  | [ y; z ] -&gt; y + z
  | y :: z :: _ -&gt; y + z + 1
in
let () =
  print_endline @@ Int.to_string
  @@ baz
       (Minidebug_runtime.debug ~global_prefix:&quot;baz-1&quot; ~values_first_mode:true ())
       [ 4 ]
in
let () =
  print_endline @@ Int.to_string
  @@ baz
       (Minidebug_runtime.debug ~global_prefix:&quot;baz-2&quot; ~values_first_mode:true ())
       [ 4; 5; 6 ]
in
[%expect
  {|
    BEGIN DEBUG SESSION foo-1
    foo = 14
    ├─&quot;test/test_expect_test.ml&quot;:2029:25-2030:55
    └─foo-1 &lt;match -- branch 1&gt; :: (y, _)
      ├─&quot;test/test_expect_test.ml&quot;:2030:50-2030:55
      └─y = 7
    14

    BEGIN DEBUG SESSION baz-1
    baz = 8
    ├─&quot;test/test_expect_test.ml&quot;:2040:15-2040:20
    ├─baz-1 &lt;function -- branch 1&gt; :: (y, [])
    └─y = 4
    8

    BEGIN DEBUG SESSION baz-2
    baz = 10
    ├─&quot;test/test_expect_test.ml&quot;:2042:21-2042:30
    ├─baz-2 &lt;function -- branch 3&gt; :: (y, :: (z, _))
    ├─y = 4
    └─z = 5
    10 |}]</code></pre></div></body></html>
